function fitISETBioModelToAOSTFdata
% Use the ISETBio computed M838 cone mosaic responses with a single cone 
% spatial pooling (DoG) model to fit the measured STF data

    targetLcenterRGCindices = [10]; %[1 3 4 5 6 7 8 10 11]; % the non-low pass cells
      % [1 2 4];   % the non-low pass cells
    
    centerConesSchema =   'single';

    %residualDefocusDiopters = 0.000;
    %residualDefocusDiopters = 0.020;
    %residualDefocusDiopters = 0.040;
    %residualDefocusDiopters = 0.055;
    %residualDefocusDiopters = 0.063;
    residualDefocusDiopters = 0.067;
    %residualDefocusDiopters = 0.072;
    %residualDefocusDiopters = 0.075;
    %residualDefocusDiopters = 0.085;
    %residualDefocusDiopters = 0.100;
    %residualDefocusDiopters = 0.125;
    %residualDefocusDiopters = 0.150;

    targetMcenterRGCindices = [];
    targetLcenterRGCindices = [1];
    batchFitISETBioModelToAOSTFdata(...
        targetLcenterRGCindices, targetMcenterRGCindices, ...
        centerConesSchema, residualDefocusDiopters);
    
    targetLcenterRGCindices = [3];
    batchFitISETBioModelToAOSTFdata(...
        targetLcenterRGCindices, targetMcenterRGCindices, ...
        centerConesSchema, residualDefocusDiopters);

     targetLcenterRGCindices = [4];
      batchFitISETBioModelToAOSTFdata(...
        targetLcenterRGCindices, targetMcenterRGCindices, ...
        centerConesSchema, residualDefocusDiopters);
    
     targetLcenterRGCindices = [5];
      batchFitISETBioModelToAOSTFdata(...
        targetLcenterRGCindices, targetMcenterRGCindices, ...
        centerConesSchema, residualDefocusDiopters);
    
     targetLcenterRGCindices = [6];
      batchFitISETBioModelToAOSTFdata(...
        targetLcenterRGCindices, targetMcenterRGCindices, ...
        centerConesSchema, residualDefocusDiopters);
    
     targetLcenterRGCindices = [7];
      batchFitISETBioModelToAOSTFdata(...
        targetLcenterRGCindices, targetMcenterRGCindices, ...
        centerConesSchema, residualDefocusDiopters);
        

end

function batchFitISETBioModelToAOSTFdata(...
    targetLcenterRGCindices, targetMcenterRGCindices, ...
    centerConesSchema, residualDefocusDiopters)

    % Multi-start >1 or single attempt
    startingPointsNum = 256;
    
    % From 2022 ARVO abstract: "RGCs whose centers were driven by cones in
    % the central 6 arcmin of the fovea"
    maxRecordedRGCeccArcMin = 6;

    % How many input cones to . Dont use less than 2 because
    % of issues with MATLAB's last dimenion dropping
    visualizedLocationsNum = 7; %Inf;
    

    % Select which model to run
    modelVariant = struct(...
        'centerConesSchema',  centerConesSchema, ... % Cones feeding into the RF center. Select between {'variable', and 'single'}
        'residualDefocusDiopters', residualDefocusDiopters, ...
        'coneCouplingLambda', 0);


    monkeyID = 'M838';


    %operationMode = 'fitModelOnSessionAveragedData';
    operationMode = 'fitModelOnSingleSessionData';
    %operationMode = 'crossValidateFittedModelOnSingleSessionData';
    %operationMode = 'crossValidateFittedModelOnAllSessionData';

    switch (operationMode)
        case 'fitModelOnSessionAveragedData'
            % Fit the model on the average (over all sessions) data
            crossValidateModel = false;
            crossValidateModelAgainstAllSessions = false;
            trainModel = [];

        case 'fitModelOnSingleSessionData'
            % Fit the model on single sessions
            crossValidateModel = true;
            crossValidateModelAgainstAllSessions = false;
            trainModel = true;

        case 'crossValidateFittedModelOnSingleSessionData'
            % Cross-validate the fitted model on other sessions
            crossValidateModel = true;
            crossValidateModelAgainstAllSessions = false;
            trainModel = false;

        case 'crossValidateFittedModelOnAllSessionData'
            % Cross-validate the fitted model on other sessions
            crossValidateModel = true;
            crossValidateModelAgainstAllSessions = true;
            trainModel = false;
    end

    tStarted = clock;
    doIt(crossValidateModel, crossValidateModelAgainstAllSessions, ...
        trainModel, monkeyID, modelVariant, ...
        maxRecordedRGCeccArcMin, visualizedLocationsNum, ...
        targetLcenterRGCindices, targetMcenterRGCindices, ...
        startingPointsNum);
    tFinished = clock;
    secondsLapsed = etime(tFinished, tStarted);
    fprintf('Finished in %2.2f hours\n', secondsLapsed/60/60);
end


function doIt(crossValidateModel, crossValidateModelAgainstAllSessions, ...
    trainModel, monkeyID, modelVariant , ...
    maxRecordedRGCeccArcMin, visualizedLocationsNum, ...
    targetLcenterRGCindices, targetMcenterRGCindices, ...
    startingPointsNum)
    
    if (~crossValidateModel)
        sessionData = 'mean';
        d = loadUncorrectedDeltaFluoresenceResponses(monkeyID, sessionData);
        dNonCrossValidatedData = struct(...
            'train',  d, ...
            'test', []);

        theTrainedModel = [];
    else
        d1 = loadUncorrectedDeltaFluoresenceResponses(monkeyID, 'session1only'); 
        d2 = loadUncorrectedDeltaFluoresenceResponses(monkeyID, 'session2only');
        d3 = loadUncorrectedDeltaFluoresenceResponses(monkeyID, 'session3only');

        % Arrange data in cross-validated pairs
        dCrossValidatedData = {};

        if (trainModel)
            % 3 non-cross validated runs (single session)
            dCrossValidatedData{numel(dCrossValidatedData)+1} = struct(...
                'train',  d1, ...
                'test', []);
            dCrossValidatedData{numel(dCrossValidatedData)}.dataSets = {'s1', 's1'};
    
            dCrossValidatedData{numel(dCrossValidatedData)+1} = struct(...
                'train',  d2, ...
                'test', []);
            dCrossValidatedData{numel(dCrossValidatedData)}.dataSets = {'s2', 's2'};
    
            dCrossValidatedData{numel(dCrossValidatedData)+1} = struct(...
                'train',  d3, ...
                'test', []);
            dCrossValidatedData{numel(dCrossValidatedData)}.dataSets = {'s3', 's3'};
        
            theTrainedModel = [];

        elseif (crossValidateModel) && (~crossValidateModelAgainstAllSessions)
            % Load the trained model params
            theTrainedModelFitsfilename = fitsFilename(modelVariant, startingPointsNum, ...
                crossValidateModel, crossValidateModelAgainstAllSessions, true, ...
                targetLcenterRGCindices, targetMcenterRGCindices);

            theTrainedModel = load(theTrainedModelFitsfilename);
 
            % 6 cross-validated runs (against single sessions)
            dCrossValidatedData{numel(dCrossValidatedData)+1} = struct(...
                'train',  d1, ...
                'test', d2);
            dCrossValidatedData{numel(dCrossValidatedData)}.dataSets = {'s1', 's2'};
    
            dCrossValidatedData{numel(dCrossValidatedData)+1} = struct(...
                'train',  d1, ...
                'test', d3);
            dCrossValidatedData{numel(dCrossValidatedData)}.dataSets = {'s1', 's3'};
    
            dCrossValidatedData{numel(dCrossValidatedData)+1} = struct(...
                'train',  d2, ...
                'test', d1);
            dCrossValidatedData{numel(dCrossValidatedData)}.dataSets = {'s2', 's1'};
    
            dCrossValidatedData{numel(dCrossValidatedData)+1} = struct(...
                'train',  d2, ...
                'test', d3);
            dCrossValidatedData{numel(dCrossValidatedData)}.dataSets = {'s2', 's3'};
    
    
            dCrossValidatedData{numel(dCrossValidatedData)+1} = struct(...
                'train',  d3, ...
                'test', d1);
            dCrossValidatedData{numel(dCrossValidatedData)}.dataSets = {'s3', 's1'};

            dCrossValidatedData{numel(dCrossValidatedData)+1} = struct(...
                'train',  d3, ...
                'test', d2);
            dCrossValidatedData{numel(dCrossValidatedData)}.dataSets = {'s3', 's2'};
        
        else
            % Load the trained model params
            theTrainedModelFitsfilename = fitsFilename(modelVariant, startingPointsNum, ...
                crossValidateModel, crossValidateModelAgainstAllSessions, true, ...
                targetLcenterRGCindices, targetMcenterRGCindices);

            theTrainedModel = load(theTrainedModelFitsfilename);
 
            % 3 cross-validated runs (against multiple sessions)
            dCrossValidatedData{numel(dCrossValidatedData)+1} = struct(...
                'train',  d1);
            dCrossValidatedData{numel(dCrossValidatedData)}.test = {d2,d3};
            dCrossValidatedData{numel(dCrossValidatedData)}.dataSets = {'s1', {'s2', 's3'}};
    
            dCrossValidatedData{numel(dCrossValidatedData)+1} = struct(...
                'train',  d2);
            dCrossValidatedData{numel(dCrossValidatedData)}.test = {d1,d3};
            dCrossValidatedData{numel(dCrossValidatedData)}.dataSets = {'s2', {'s1', 's3'}};
    
            dCrossValidatedData{numel(dCrossValidatedData)+1} = struct(...
                'train',  d3);
            dCrossValidatedData{numel(dCrossValidatedData)}.test = {d1,d2};
            dCrossValidatedData{numel(dCrossValidatedData)}.dataSets = {'s3', {'s1', 's2'}};

        end
        
    end
    
    
    % Load the monkey cone mosaic data
    c = loadConeMosaicData(monkeyID, maxRecordedRGCeccArcMin);
    
    % ISETBio simulation parameters.
    sParams = struct(...
        'PolansSubject', [], ...                % [] = diffraction-limited optics
        'modelVariant', modelVariant, ... 
        'visualStimulus', struct(...
                 'type', 'WilliamsLabStimulus', ...
                 'stimulationDurationCycles', 6));

    % Load the ISETBio computed time-series responses for the simulated STF run
    modelSTFrunData = loadPrecomputedISETBioConeMosaicSTFrunData(monkeyID, sParams);

    % Transform excitations signal (e) to a contrast signal (c), using the
    % background excitations signal (b): c = (e-b)/b;
    b = modelSTFrunData.coneMosaicBackgroundActivation;
    modelSTFrunData.coneMosaicSpatiotemporalActivation = ...
        bsxfun(@times, bsxfun(@minus, modelSTFrunData.coneMosaicSpatiotemporalActivation, b), 1./b);


    % Generate the fits filename
    theFitsFilename = fitsFilename(modelVariant, startingPointsNum, ...
        crossValidateModel, crossValidateModelAgainstAllSessions, trainModel, ...
        targetLcenterRGCindices, targetMcenterRGCindices);
    
    if (~isempty(targetLcenterRGCindices))
        fprintf('Fitting L-center cells\n');
        % Find the indices of model L-cones that could provide input to the L-center RGCs
        indicesOfModelConesDrivingLcenterRGCs = indicesOfModelConesWithinEccDegs(...
            modelSTFrunData.theConeMosaic, ...
            modelSTFrunData.theConeMosaic.LCONE_ID, ...
            maxRecordedRGCeccArcMin/60);
        
        
        % Do a subset of these
        if (numel(indicesOfModelConesDrivingLcenterRGCs)>visualizedLocationsNum)
            skip = round(numel(indicesOfModelConesDrivingLcenterRGCs)/visualizedLocationsNum);
            idx = 1:skip:numel(indicesOfModelConesDrivingLcenterRGCs);
            indicesOfModelConesDrivingLcenterRGCs = indicesOfModelConesDrivingLcenterRGCs(idx);
            if (numel(indicesOfModelConesDrivingLcenterRGCs) > visualizedLocationsNum)
                indicesOfModelConesDrivingLcenterRGCs = indicesOfModelConesDrivingLcenterRGCs(1:visualizedLocationsNum);
            end
        end

        % Fit the L-center RGCs using the model L-cones that could provide
        % input to the RF centers
        if (~crossValidateModel)
            % No cross-validation, using the mean data
            iCrossValidationRun = 0;
            [fittedParamsLcenterRGCs, ...
             fittedSTFsLcenterRGCs, ...
             rmsErrorsLcenterRGCs, ...
             rmsErrorsTrainLcenterRGCs, ...
             centerLConeCharacteristicRadiiDegs, ...
             centerConesFractionalNumLcenterRGCs, centroidPositionLcenterRGCs, ...
             centerConeIndicesLcenterRGCs, centerConeWeightsLcenterRGCs, ...
             surroundConeIndicesLcenterRGCs, surroundConeWeightsLcenterRGCs ...
             ] = fitModelToSessionData(...
                            theTrainedModel, ...
                            modelSTFrunData, ...
                            indicesOfModelConesDrivingLcenterRGCs, ...
                            dNonCrossValidatedData, iCrossValidationRun, ...
                            startingPointsNum, 'L', modelVariant, targetLcenterRGCindices);
        else
            % Cross-validated runs, using individual session data
            if (trainModel)
                for iCrossValidationRun = 1:numel(dCrossValidatedData)
                    [fittedParamsLcenterRGCs{iCrossValidationRun}, ...
                     fittedSTFsLcenterRGCs{iCrossValidationRun}, ...
                     rmsErrorsLcenterRGCs{iCrossValidationRun}, ...
                     rmsErrorsTrainLcenterRGCs{iCrossValidationRun}, ...
                     centerLConeCharacteristicRadiiDegs{iCrossValidationRun}, ...
                     centerConesFractionalNumLcenterRGCs{iCrossValidationRun}, centroidPositionLcenterRGCs{iCrossValidationRun}, ...
                     centerConeIndicesLcenterRGCs{iCrossValidationRun}, centerConeWeightsLcenterRGCs{iCrossValidationRun}, ...
                     surroundConeIndicesLcenterRGCs{iCrossValidationRun}, surroundConeWeightsLcenterRGCs{iCrossValidationRun} ...
                     ] = fitModelToSessionData(...
                                theTrainedModel, ...
                                modelSTFrunData, ...
                                indicesOfModelConesDrivingLcenterRGCs, ...
                                dCrossValidatedData{iCrossValidationRun}, iCrossValidationRun, ...
                                startingPointsNum, 'L', modelVariant, targetLcenterRGCindices);
                end
            else
                for iCrossValidationRun = 1:numel(dCrossValidatedData)
                    [fittedParamsLcenterRGCs{iCrossValidationRun}, ...
                     fittedSTFsLcenterRGCs{iCrossValidationRun}, ...
                     rmsErrorsLcenterRGCs{iCrossValidationRun}, ...
                     rmsErrorsTrainLcenterRGCs{iCrossValidationRun}, ...
                     centerLConeCharacteristicRadiiDegs{iCrossValidationRun}, ...
                     centerConesFractionalNumLcenterRGCs{iCrossValidationRun}, centroidPositionLcenterRGCs{iCrossValidationRun}, ...
                     centerConeIndicesLcenterRGCs{iCrossValidationRun}, centerConeWeightsLcenterRGCs{iCrossValidationRun}, ...
                     surroundConeIndicesLcenterRGCs{iCrossValidationRun}, surroundConeWeightsLcenterRGCs{iCrossValidationRun} ...
                     ] = fitModelToSessionData(...
                                theTrainedModel, ...
                                modelSTFrunData, ...
                                indicesOfModelConesDrivingLcenterRGCs, ...
                                dCrossValidatedData{iCrossValidationRun}, iCrossValidationRun, ...
                                startingPointsNum, 'L', modelVariant, targetLcenterRGCindices);
                end
           
            end

        end

        % Save the L-center data
        save(theFitsFilename,...
            'fittedParamsLcenterRGCs', 'centerLConeCharacteristicRadiiDegs', ...
            'centerConesFractionalNumLcenterRGCs', 'centroidPositionLcenterRGCs', ...
            'centerConeIndicesLcenterRGCs', 'centerConeWeightsLcenterRGCs', ...
            'surroundConeIndicesLcenterRGCs', 'surroundConeWeightsLcenterRGCs', ...
            'fittedSTFsLcenterRGCs', 'rmsErrorsLcenterRGCs', 'rmsErrorsTrainLcenterRGCs', ...
            'targetLcenterRGCindices', ...
            'indicesOfModelConesDrivingLcenterRGCs');
    end % if (~isempty(targetLcenterRGCindices))


    
    if (~isempty(targetMcenterRGCindices))
        fprintf('Fitting M-center cells\n');
        % Find the indices of model M-cones that could provide input to the M-center RGCs
        indicesOfModelConesDrivingMcenterRGCs = indicesOfModelConesWithinEccDegs(...
            modelSTFrunData.theConeMosaic, ...
            modelSTFrunData.theConeMosaic.MCONE_ID, ...
            maxRecordedRGCeccArcMin/60);
        
        % Do a subset of these
        if (numel(indicesOfModelConesDrivingMcenterRGCs)>visualizedLocationsNum)
            skip = round(numel(indicesOfModelConesDrivingMcenterRGCs)/visualizedLocationsNum);
            idx = 1:skip:numel(indicesOfModelConesDrivingMcenterRGCs);
            indicesOfModelConesDrivingMcenterRGCs = indicesOfModelConesDrivingMcenterRGCs(idx);
            if (numel(indicesOfModelConesDrivingMcenterRGCs) > visualizedLocationsNum)
                indicesOfModelConesDrivingMcenterRGCs = indicesOfModelConesDrivingMcenterRGCs(1:visualizedLocationsNum);
            end
        end

        % Fit the M-center RGCs using the model M-cones that could provide
        % input to the RF centers
        if (~crossValidateModel)
            % No cross-validation, using the mean data
            iCrossValidationRun = 0;

            [fittedParamsMcenterRGCs, ...
             fittedSTFsMcenterRGCs, ...
             rmsErrorsMcenterRGCs, ...
             rmsErrorsTrainMcenterRGCs, ...
             centerMConeCharacteristicRadiiDegs, ...
             centerConesFractionalNumMcenterRGCs, centroidPositionMcenterRGCs, ...
             centerConeIndicesMcenterRGCs, centerConeWeightsMcenterRGCs, ...
             surroundConeIndicesMcenterRGCs, surroundConeWeightsMcenterRGCs ...
             ] = fitModelToSessionData(...
                            [], ...
                            modelSTFrunData, ...
                            indicesOfModelConesDrivingMcenterRGCs, ...
                            dNonCrossValidatedData, iCrossValidationRun, ...
                            startingPointsNum, 'M', modelVariant, targetMcenterRGCindices );
        else
            % Cross-validated runs, using individual session data
            if (trainModel)  
                for iCrossValidationRun = 1:numel(dCrossValidatedData)
                    [fittedParamsMcenterRGCs{iCrossValidationRun}, ...
                     fittedSTFsMcenterRGCs{iCrossValidationRun}, ...
                     rmsErrorsMcenterRGCs{iCrossValidationRun}, ...
                     rmsErrorsTrainMcenterRGCs{iCrossValidationRun}, ...
                     centerMConeCharacteristicRadiiDegs{iCrossValidationRun}, ...
                     centerConesFractionalNumMcenterRGCs{iCrossValidationRun}, centroidPositionMcenterRGCs{iCrossValidationRun}, ...
                     centerConeIndicesMcenterRGCs{iCrossValidationRun}, centerConeWeightsMcenterRGCs{iCrossValidationRun}, ...
                     surroundConeIndicesMcenterRGCs{iCrossValidationRun}, surroundConeWeightsMcenterRGCs{iCrossValidationRun} ...
                     ] = fitModelToSessionData(...
                                [], ...
                                modelSTFrunData, ...
                                indicesOfModelConesDrivingMcenterRGCs, ...
                                dCrossValidatedData{iCrossValidationRun}, iCrossValidationRun, ...
                                startingPointsNum, 'M', modelVariant, targetMcenterRGCindices );
                end
            else
                for iCrossValidationRun = 1:numel(dCrossValidatedData)
                    [fittedParamsMcenterRGCs{iCrossValidationRun}, ...
                     fittedSTFsMcenterRGCs{iCrossValidationRun}, ...
                     rmsErrorsMcenterRGCs{iCrossValidationRun}, ...
                     rmsErrorsTrainMcenterRGCs{iCrossValidationRun}, ...
                     centerMConeCharacteristicRadiiDegs{iCrossValidationRun}, ...
                     centerConesFractionalNumMcenterRGCs{iCrossValidationRun}, centroidPositionMcenterRGCs{iCrossValidationRun}, ...
                     centerConeIndicesMcenterRGCs{iCrossValidationRun}, centerConeWeightsMcenterRGCs{iCrossValidationRun}, ...
                     surroundConeIndicesMcenterRGCs{iCrossValidationRun}, surroundConeWeightsMcenterRGCs{iCrossValidationRun} ...
                     ] = fitModelToSessionData(...
                                theTrainedModel, ...
                                modelSTFrunData, ...
                                indicesOfModelConesDrivingMcenterRGCs, ...
                                dCrossValidatedData{iCrossValidationRun}, iCrossValidationRun, ...
                                startingPointsNum, 'M', modelVariant, targetMcenterRGCindices);
                end
            end

        end


        % Save the M-center data
        if (exist(theFitsFilename, 'file'))
            % Append to file
            save(theFitsFilename,...
                'fittedParamsMcenterRGCs', 'centerMConeCharacteristicRadiiDegs', ...
                'centerConesFractionalNumMcenterRGCs', 'centroidPositionMcenterRGCs', ...
                'centerConeIndicesMcenterRGCs', 'centerConeWeightsMcenterRGCs', ...
                'surroundConeIndicesMcenterRGCs', 'surroundConeWeightsMcenterRGCs', ...
                'fittedSTFsMcenterRGCs', 'rmsErrorsMcenterRGCs', 'rmsErrorsTrainMcenterRGCs', ...
                'indicesOfModelConesDrivingMcenterRGCs', ...
                'targetMcenterRGCindices', ...
                'startingPointsNum', '-append');
        else
            save(theFitsFilename,...
                'fittedParamsMcenterRGCs', 'centerMConeCharacteristicRadiiDegs', ...
                'centerConesFractionalNumMcenterRGCs', 'centroidPositionMcenterRGCs', ...
                'centerConeIndicesMcenterRGCs', 'centerConeWeightsMcenterRGCs', ...
                'surroundConeIndicesMcenterRGCs', 'surroundConeWeightsMcenterRGCs', ...
                'fittedSTFsMcenterRGCs', 'rmsErrorsMcenterRGCs', 'rmsErrorsTrainMcenterRGCs', ...
                'indicesOfModelConesDrivingMcenterRGCs', ...
                'targetMcenterRGCindices', ...
                'startingPointsNum');
        end       
    end % if (~isempty(targetMcenterRGCindices))
end